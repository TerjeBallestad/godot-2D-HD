---
phase: 03-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scenes/interior/interior_scene.tscn
  - scenes/character/player_character.gd
  - scenes/character/player_character.tscn
autonomous: true

must_haves:
  truths:
    - "Left-clicking on floor moves character to that position"
    - "Character moves smoothly with eased acceleration/deceleration"
    - "Character navigates around furniture (does not clip through)"
    - "Clicking new destination while moving redirects character immediately"
  artifacts:
    - path: "scenes/interior/interior_scene.tscn"
      provides: "NavigationRegion3D with baked navigation mesh"
      contains: "NavigationRegion3D"
    - path: "scenes/character/player_character.gd"
      provides: "Click-to-move navigation with eased motion"
      min_lines: 50
    - path: "scenes/character/player_character.tscn"
      provides: "NavigationAgent3D node"
      contains: "NavigationAgent3D"
  key_links:
    - from: "scenes/character/player_character.gd"
      to: "NavigationAgent3D"
      via: "target_position assignment and velocity_computed signal"
      pattern: "navigation_agent\\.target_position|velocity_computed"
    - from: "scenes/character/player_character.gd"
      to: "floor raycast"
      via: "mouse click to world position conversion"
      pattern: "project_ray_origin|intersect_ray"
---

<objective>
Click-to-move character navigation with pathfinding and smooth eased motion.

Purpose: Enable player to navigate the interior scene by clicking on the floor, allowing evaluation of how the character moves through the HD-2D environment.

Output: Working click-to-move system where left-clicking on floor moves character smoothly with acceleration/deceleration, navigating around furniture.
</objective>

<execution_context>
@/Users/godstemning/.claude/get-shit-done/workflows/execute-plan.md
@/Users/godstemning/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-controls/03-CONTEXT.md
@.planning/phases/03-controls/03-RESEARCH.md
@.planning/phases/02-character/02-01-SUMMARY.md
@scenes/character/player_character.gd
@scenes/character/player_character.tscn
@scenes/interior/interior_scene.tscn
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up NavigationRegion3D and bake navigation mesh</name>
  <files>scenes/interior/interior_scene.tscn</files>
  <action>
Add NavigationRegion3D to interior_scene.tscn with NavigationMesh resource configured for the room:

1. Add NavigationRegion3D node as child of InteriorScene root
2. Create NavigationMesh resource with settings:
   - agent_radius: 0.3 (character collision radius + margin)
   - agent_height: 1.0 (character height)
   - cell_size: 0.1 (navigation precision)
   - cell_height: 0.1
   - geometry_parsed_geometry_type: PARSED_GEOMETRY_STATIC_COLLIDERS (bake from static colliders)
   - geometry_source_geometry_mode: SOURCE_GEOMETRY_ROOT_NODE_CHILDREN

3. Ensure FloorCollider StaticBody3D has collision_layer = 1 (already set in 02-01)
4. The furniture models (Sofa, CoffeeTable, Chairs, etc.) will create obstacles in the navmesh if they have collision shapes

IMPORTANT: The navmesh must be baked. In Godot 4, this is done via editor or script. For the scene file, set the navigation_mesh property with the resource and Godot will bake on scene load if using bake_navigation_mesh() in _ready().

Add a simple script to interior_scene.gd (or extend existing) to bake navmesh on ready:
```gdscript
func _ready() -> void:
    var nav_region = $NavigationRegion3D
    if nav_region:
        nav_region.bake_navigation_mesh()
```
  </action>
  <verify>
Open interior_scene.tscn in Godot editor. The NavigationRegion3D should show a blue navmesh overlay on the walkable floor area, with holes around furniture.
  </verify>
  <done>
NavigationRegion3D exists with NavigationMesh baked from floor and furniture geometry. Walkable areas are defined, obstacles create holes in navmesh.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement click-to-move with NavigationAgent3D and eased motion</name>
  <files>scenes/character/player_character.gd, scenes/character/player_character.tscn</files>
  <action>
Modify player_character.tscn to add NavigationAgent3D:

1. Add NavigationAgent3D node as child of PlayerCharacter (CharacterBody3D)
2. Configure NavigationAgent3D:
   - path_desired_distance: 0.3 (generous threshold per research)
   - target_desired_distance: 0.3 (same value to avoid confusion)
   - avoidance_enabled: false (simple pathfinding is sufficient)
   - max_speed: 1.5 (slow/deliberate pace - 3-4 sec to cross ~5m room)

Rewrite player_character.gd for click-to-move with eased motion:

```gdscript
extends CharacterBody3D
## Click-to-move character controller with NavigationAgent3D and eased motion.

@onready var shadow_caster: ShapeCast3D = $ShadowCaster
@onready var blob_shadow: Decal = $ShadowCaster/BlobShadow
@onready var navigation_agent: NavigationAgent3D = $NavigationAgent3D

# Movement parameters
const MAX_SPEED: float = 1.5  # Units per second (slow/deliberate)
const ACCELERATION: float = 3.0  # How fast to reach max speed
const DECELERATION: float = 4.0  # How fast to slow down near destination

var current_speed: float = 0.0
var is_moving: bool = false

func _ready() -> void:
    # Wait for navigation to be ready (per research pitfall #1)
    await get_tree().physics_frame
    navigation_agent.velocity_computed.connect(_on_velocity_computed)

func _unhandled_input(event: InputEvent) -> void:
    # Left click to move (per discretionary decision)
    if event is InputEventMouseButton:
        if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
            _handle_click(event.position)

func _handle_click(screen_pos: Vector2) -> void:
    var camera = get_viewport().get_camera_3d()
    if not camera:
        return

    var from = camera.project_ray_origin(screen_pos)
    var to = from + camera.project_ray_normal(screen_pos) * 100.0

    var space_state = get_world_3d().direct_space_state
    var query = PhysicsRayQueryParameters3D.create(from, to)
    query.collision_mask = 1  # Floor collision layer
    query.collide_with_areas = false

    var result = space_state.intersect_ray(query)
    if result:
        _set_movement_target(result.position)

func _set_movement_target(target_pos: Vector3) -> void:
    navigation_agent.target_position = target_pos
    is_moving = true

func _physics_process(delta: float) -> void:
    _update_shadow()
    _update_movement(delta)

func _update_movement(delta: float) -> void:
    if not is_moving:
        return

    if navigation_agent.is_navigation_finished():
        is_moving = false
        current_speed = 0.0
        velocity = Vector3.ZERO
        return

    var next_pos = navigation_agent.get_next_path_position()
    var direction = (next_pos - global_position).normalized()
    direction.y = 0  # Keep movement horizontal

    # Calculate distance to final target for deceleration
    var distance_to_target = global_position.distance_to(navigation_agent.target_position)
    var decel_distance = (current_speed * current_speed) / (2.0 * DECELERATION)

    # Eased motion: accelerate at start, decelerate near end
    if distance_to_target < decel_distance:
        # Decelerate
        current_speed = maxf(current_speed - DECELERATION * delta, 0.2)
    else:
        # Accelerate up to max speed
        current_speed = minf(current_speed + ACCELERATION * delta, MAX_SPEED)

    var desired_velocity = direction * current_speed
    navigation_agent.velocity = desired_velocity

func _on_velocity_computed(safe_velocity: Vector3) -> void:
    velocity = safe_velocity
    move_and_slide()

func _update_shadow() -> void:
    if shadow_caster.get_collision_count() > 0:
        var hit_point = shadow_caster.get_collision_point(0)
        blob_shadow.global_position = hit_point + Vector3(0, 0.01, 0)
        blob_shadow.visible = true
    else:
        blob_shadow.visible = false
```

Key implementation notes:
- Use _unhandled_input() to avoid UI blocking raycasts (per research pitfall #6)
- Use call_deferred pattern via await physics_frame (per research pitfall #1)
- Raycast with collision_mask = 1 to hit floor only (per research pitfall #4)
- Eased motion via acceleration/deceleration based on distance to target
- Clicking new destination sets new target_position (immediate redirect)
  </action>
  <verify>
Run the scene. Left-click on the floor:
1. Character should move toward clicked position
2. Movement should start slow, speed up, then slow down before stopping
3. Character should navigate around furniture (not clip through)
4. Clicking a new spot while moving should redirect immediately
  </verify>
  <done>
Left-clicking floor moves character smoothly with eased motion. Navigation avoids furniture. Clicking new destination while moving redirects immediately.
  </done>
</task>

</tasks>

<verification>
Run interior_scene.tscn:
1. Left-click on various floor positions - character should pathfind there
2. Observe smooth acceleration at start and deceleration near destination
3. Click behind furniture - character should path around it
4. Mid-movement, click elsewhere - character should redirect without stopping
5. Click on furniture or walls - character should not move (raycast misses floor)
</verification>

<success_criteria>
- NavigationRegion3D exists with baked navmesh showing walkable areas
- Left-click on floor moves character to that position
- Movement has visible easing (not constant speed)
- Character avoids furniture via navigation
- Clicking new destination during movement redirects immediately
</success_criteria>

<output>
After completion, create `.planning/phases/03-controls/03-01-SUMMARY.md`
</output>
